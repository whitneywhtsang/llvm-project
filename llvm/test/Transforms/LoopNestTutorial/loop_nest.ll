; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes='loop-nest-tutorial' -S < %s 2>&1 | FileCheck %s

define void @perfectloopnest() {
; CHECK-LABEL: @perfectloopnest(
; CHECK-NEXT:  preheader.outer:
; CHECK-NEXT:    br label [[HEADER_INNER:%.*]]
; CHECK:       header.outer:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, [[HEADER_INNER]] ], [ [[INC_OUTER:%.*]], [[LATCH_OUTER:%.*]] ]
; CHECK-NEXT:    br label [[LOOPBODYFIRST:%.*]]
; CHECK:       header.inner:
; CHECK-NEXT:    [[J:%.*]] = phi i32 [ 0, [[PREHEADER_OUTER:%.*]] ], [ [[INC_INNER:%.*]], [[LATCH_INNER:%.*]] ]
; CHECK-NEXT:    br label [[HEADER_OUTER:%.*]]
; CHECK:       loopbodyfirst:
; CHECK-NEXT:    call void @foo(i32 [[I]], i32 [[J]])
; CHECK-NEXT:    [[INC_INNER]] = add nsw i32 [[J]], 1
; CHECK-NEXT:    [[CMP_INNER:%.*]] = icmp slt i32 [[INC_INNER]], 100
; CHECK-NEXT:    br label [[LATCH_OUTER]]
; CHECK:       latch.inner:
; CHECK-NEXT:    br i1 [[CMP_INNER]], label [[HEADER_INNER]], label [[EXIT_OUTER:%.*]]
; CHECK:       latch.outer:
; CHECK-NEXT:    [[INC_OUTER]] = add nsw i32 [[I]], 1
; CHECK-NEXT:    [[CMP_OUTER:%.*]] = icmp slt i32 [[INC_OUTER]], 100
; CHECK-NEXT:    br i1 [[CMP_OUTER]], label [[HEADER_OUTER]], label [[LATCH_INNER]]
; CHECK:       exit.outer:
; CHECK-NEXT:    ret void
;
preheader.outer:
  br label %header.outer

header.outer:
  %i = phi i32 [ 0, %preheader.outer ], [ %inc.outer, %latch.outer ]
  br label %header.inner

header.inner:
  %j = phi i32 [ 0, %header.outer ], [ %inc.inner, %header.inner ]
  call void @foo(i32 %i, i32 %j)
  %inc.inner = add nsw i32 %j, 1
  %cmp.inner = icmp slt i32 %inc.inner, 100
  br i1 %cmp.inner, label %header.inner, label %latch.outer

latch.outer:
  %inc.outer = add nsw i32 %i, 1
  %cmp.outer = icmp slt i32 %inc.outer, 100
  br i1 %cmp.outer, label %header.outer, label %exit.outer

exit.outer:
  ret void
}

declare void @foo(i32, i32)
